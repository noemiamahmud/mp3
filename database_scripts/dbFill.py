#!/usr/bin/env python

"""
 * FIXED dbFill.py
 * Fully compatible with Render + your API
 * Includes HTTPS, SSL bypass, retry logic, safe parsing
"""

import sys
import getopt
import http.client
import urllib
import json
from random import randint, choice
from datetime import date
from time import mktime
import ssl
import time

# Disable SSL verification (Render cert chain mismatch on macOS Python)
ssl._create_default_https_context = ssl._create_unverified_context


def usage():
    print('dbFill.py -u <baseurl> -p <port> -n <numUsers> -t <numTasks>')


def safe_json(raw):
    """Safely parse JSON or return empty dict."""
    try:
        return json.loads(raw)
    except:
        return {}


def post_with_retry(conn, path, params, headers):
    """
    Makes POST request with automatic retry for rate limits (429).
    Returns parsed JSON.
    """

    for attempt in range(5):  # retry up to 5 times
        conn.request("POST", path, params, headers)
        response = conn.getresponse()
        raw = response.read()
        data = safe_json(raw)

        status = response.status

        if status == 429:
            print("‚ö†Ô∏è  Hit 429 rate limit ‚Äî retrying...")
            time.sleep(1.0)
            continue

        if status >= 400:
            print(f"‚ùå POST {path} failed ({status}):", raw)
            return None

        return data

    print(f"‚ùå POST {path} failed too many times.")
    return None


def main(argv):
    baseurl = "localhost"
    port = 4000
    userCount = 50
    taskCount = 200

    # Parse args
    try:
        opts, args = getopt.getopt(argv, "hu:p:n:t:", ["url=", "port=", "users=", "tasks="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt == "-h":
            usage()
            sys.exit()
        elif opt in ("-u", "--url"):
            baseurl = str(arg)
        elif opt in ("-p", "--port"):
            port = int(arg)
        elif opt in ("-n", "--users"):
            userCount = int(arg)
        elif opt in ("-t", "--tasks"):
            taskCount = int(arg)

    # Sample names
    firstNames = ["james", "john", "robert", "michael", "william",
                  "david", "richard", "charles", "joseph", "thomas"]
    lastNames = ["smith", "johnson", "williams", "jones", "brown",
                 "davis", "miller", "wilson", "moore", "taylor"]

    conn = http.client.HTTPSConnection(baseurl, port)
    headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "application/json"}

    userIDs = []
    userNames = []

    print("‚û°Ô∏è Creating users...")

    # --------------------------------------------------------------
    # CREATE USERS
    # --------------------------------------------------------------
    for i in range(userCount):
        x = randint(0, len(firstNames)-1)
        y = randint(0, len(lastNames)-1)

        params = urllib.parse.urlencode({
            'name': firstNames[x] + " " + lastNames[y],
            'email': f"{firstNames[x]}_{randint(1,99999)}@{lastNames[y]}.com"  # avoid duplicates
        })

        result = post_with_retry(conn, "/api/users", params, headers)
        if not result or "data" not in result or "_id" not in result["data"]:
            print("‚ùå Skipping user due to bad response:", result)
            continue

        userIDs.append(result["data"]["_id"])
        userNames.append(result["data"]["name"])

    print(f"‚úÖ Created {len(userIDs)} users")

    # --------------------------------------------------------------
    # CREATE TASKS
    # --------------------------------------------------------------
    print("‚û°Ô∏è Creating tasks...")

    with open("tasks.txt", "r") as f:
        taskNames = f.read().splitlines()

    for i in range(taskCount):

        assigned = (randint(0, 10) > 4)
        completed = (randint(0, 10) > 5)

        if assigned and userIDs:
            idx = randint(0, len(userIDs)-1)
            assignedUserID = userIDs[idx]
            assignedUserName = userNames[idx]
        else:
            assignedUserID = ""
            assignedUserName = "unassigned"

        deadline = (mktime(date.today().timetuple()) + randint(86400, 864000)) * 1000

        params = urllib.parse.urlencode({
            'name': choice(taskNames),
            'deadline': deadline,
            'description': "Autogenerated task.",
            'assignedUser': assignedUserID,
            'assignedUserName': assignedUserName,
            'completed': str(completed).lower()
        })

        result = post_with_retry(conn, "/api/tasks", params, headers)
        if not result:
            print("‚ùå Task failed:", result)

    conn.close()
    print(f"üéâ DONE ‚Äî Added {len(userIDs)} users and {taskCount} tasks at {baseurl}:{port}")


if __name__ == "__main__":
    main(sys.argv[1:])
